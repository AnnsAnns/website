<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="tomGER"><meta name=description content="Interesting stories about programming languages, libraries, tools and much more."><meta name=generator content="Hugo 0.71.1"><title>Using Rust for Game Servers (+ Godot) &#183; tomGER's Blog</title><link rel="shortcut icon" href=https://tomger.eu/images/favicon.ico><link rel=stylesheet href=https://tomger.eu/css/spectre.min.css async defer><link rel=stylesheet href=https://tomger.eu/css/style.css async defer><link rel=stylesheet href=https://tomger.eu/css/highlight.css async defer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css defer><meta property="og:title" content="Using Rust for Game Servers (+ Godot)"><meta property="og:description" content="Is Rust a worthwhile companion for game devs? To test this, we create our own server for a game in Godot"><meta property="og:type" content="article"><meta property="og:url" content="https://tomger.eu/posts/rust-game-lobby-system/"><meta property="og:image" content="https://tomger.eu/godot-main-menu.png"><meta property="article:published_time" content="2021-04-17T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-17T00:00:00+00:00"><meta itemprop=name content="Using Rust for Game Servers (+ Godot)"><meta itemprop=description content="Is Rust a worthwhile companion for game devs? To test this, we create our own server for a game in Godot"><meta itemprop=datePublished content="2021-04-17T00:00:00+00:00"><meta itemprop=dateModified content="2021-04-17T00:00:00+00:00"><meta itemprop=wordCount content="1778"><meta itemprop=image content="https://tomger.eu/godot-main-menu.png"><meta itemprop=keywords content="rust,game,godot,"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tomger.eu/godot-main-menu.png"><meta name=twitter:title content="Using Rust for Game Servers (+ Godot)"><meta name=twitter:description content="Is Rust a worthwhile companion for game devs? To test this, we create our own server for a game in Godot"></head><body><div class="container p-fixed" style=z-index:3><nav class="navbar m-2 p-2 s-rounded shadow bg-primary"><section class=navbar-section><button class="btn btn-action btn-primary pixel" aria-label="Change Colour" id=pixelfont-toggle><i class="fas fa-lightbulb fa-lg"></i></button>
<a class="btn btn-primary pixel mx-2" href=https://tomger.eu/>Home</a></section><section class="navbar-section pixel"><a class="btn btn-primary" href=https://ko-fi.com/tomGER>Donate (Ko-Fi)</a>
<a class="btn btn-primary mx-2" aria-label=About href=/about/>About</a></section></nav></div><section class="container grid-md"><div class=columns><article class="container p-centered mt-space"><header><h2 class=text-center>Using Rust for Game Servers (+ Godot)</h2><h6 class="text-gray text-italic text-center">Is Rust a worthwhile companion for game devs? To test this, we create our own server for a game in Godot</h6></header><section class=my-gap><figure class=text-center><img src=terminal-rocket.png alt="The power of Rust web libraries ðŸ¦€ðŸ¦€ðŸ¦€" width=70% height=70%></figure><p>I really enjoy creating games but when it comes to games, there is always one daunting task that game devs are scared off, online multiplayer. As soon as anything touches the web, it suddenly becomes a technical challenge to implement properly, esp. lobbies are among the worst contenders given that you somehow gotta exchange data between all clients.</p><p>The enormous upside however, is that multiplayer games are the games I tend to come back to much oftener than singleplayer games. One of my most favorite party games is probably Jackbox Party Pack, a game where each client connects to a centralized server.</p><h3 id=the-beginning>The Beginning</h3><p>One night I had a quite random thought, what if I created my own jackbox. I spend the entire last year learning Golang as I usually try to at least create some sort of proof of concept application for nearly all fields a language specializes in order to fully understand all it&rsquo;s mechanics. This year I decided to undergo this process with Rust, a language I have grown to love really quickly as you can see by my blog post about <a href=https://tomger.eu/posts/cross-compile-rust-wsl/>cross compiling</a> or <a href=https://tomger.eu/posts/rust-microcontrollers/>embedded programming</a>, as such, it only made sense to try to create my reimplementation in Rust.</p><p>However, as much as I love Rust, I gotta admit something, in terms of GUIs, it is still quite <em>extremely</em> lacking behind other programming languages. Like, there are many great libraries for it already but given that this should be a proof of concept server for an actual game, I decided to use Godot, a contender for the spot of Unreal and Unity in the game engine world, as the frontend.</p><figure class=text-center><img src=galaxybrain.jpg alt="Funny meme about thinking" width=20% height=20%><figcaption><p><em>Me using my entire brain power to decide what to use in my simple proof of concept game</em></p></figcaption></figure><p>Given the fact that this project would have had to have 2 different codebases for front- and backend I did not mind either way and this provided me with a great opportunity to work with Godot once again.</p><p>Another thing I decided was that the server should be nearly stateless. This gave me a great excuse to improve my knowledge about database integrations and also meant that the server would be much more performant, since yâ€™know, it didnâ€™t have to store anything in memory for longer than a few seconds.</p><p>I honestly had a hard time picking the right DB. I knew that most of the stored data would be temporary either way and I did not want my database to slow anything down. I also like the key & value system hashmaps or python dictionaries offer. As such, Redis was a natural contender.</p><h3 id=wsl-madness>WSL Madness</h3><p>This section is probably not that interesting for people that are smart enough to simply use normal linux. But those who are monkey brain such as me, did you know that you can easily start systemd services in WSL through some <em>m a g i c</em>. The magic in question is <a href=https://github.com/arkane-systems/genie>Genie</a>. Even though I use WSL for nearly all my projects, this was honestly the first time I required something to be run as a service, that being my DB -> Redis, as such, this was the first time I was required to actually use systemd.</p><figure class=text-center><img src=genie.png alt=Genie width=35% height=35%></figure><p>Thanks to the techniques Genie uses, you can simply execute &ldquo;genie -s&rdquo; in any WSL terminal and create a proper environment to start redis in and sure enough, even though it took some while for me to figure it out, it works quite flawlessly.</p><h3 id=rocket-hyper-warp-or-actix>Rocket, Hyper, Warp or ActiX</h3><p>Rust has a lot of different web frameworks and to be honest, it was kinda overwhelming and while I later regretted my choice, I chose Rocket as my web framework for this project. Rocket is easy to use, like, <em>really easy to use</em>. The syntax is so unimaginably easy to understand and boilerplate-free that it is honestly a blessing to work with it and the community support for it seemed good enough too.</p><p>Most of the boilerplate is hidden behind really easy to use macros, which is probably one of Rust&rsquo;s strongest features. Even though I would love to tell you about their amazing features in more detail, I am way too underqualified for that. If you actually want to read blog posts from somebody that understands them in great detail, I&rsquo;d recommend the blog posts by the macro king <a href=https://jam1.re/>jam1garner</a>.</p><p>To get started with Rocket, all you need to write is literally just this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#ff79c6>#![feature(proc_macro_hygiene, decl_macro)]</span>

<span style=color:#ff79c6>#[macro_use]</span> <span style=color:#ff79c6>extern</span> <span style=color:#ff79c6>crate</span> rocket;

<span style=color:#ff79c6>#[get(</span><span style=color:#f1fa8c>&#34;/&lt;name&gt;/&lt;age&gt;&#34;</span><span style=color:#ff79c6>)]</span>
<span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>hello</span>(name: <span style=color:#8be9fd;font-style:italic>String</span>, age: <span style=color:#8be9fd>u8</span>) -&gt; <span style=color:#8be9fd;font-style:italic>String</span> {
    format<span style=color:#ff79c6>!</span>(<span style=color:#f1fa8c>&#34;Hello, {} year old named {}!&#34;</span>, age, name)
}

<span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() {
    rocket::ignite().mount(<span style=color:#f1fa8c>&#34;/hello&#34;</span>, routes<span style=color:#ff79c6>!</span>[hello]).launch();
}
</code></pre></div><h3 id=creating-the-backend>Creating the backend</h3><p>This blog post is already big enough as it is, if I were to explain each API point I created, it&rsquo;d probably be another 1000 words of me rambling. As such I&rsquo;ve decided to simply explain the structure of each endpoint. For more informations about all the endpoints, please read the <a href=https://github.com/tumGER/tom_party#backend-api>ReadMe</a> which I honestly spend too much time on.</p><p>Basically, each end point (except heartbeats) is a POST request to the server. The server knows nothing about the client and as such, the client has to authenticate itself with certain values inside the body. (Again, read the <a href=https://github.com/tumGER/tom_party#backend-api>ReadMe</a> for a much more detailed explanation).</p><p>The server then responds with a JSON that returns all the relevant information about the request. For example, if you create an invite code, the server needs to know the uuid of the game and the uuid of your user that you previously received. It then compares those values to data stored inside the Redis DB and returns the newly generated invite code back to you. The server never trusts the client with any data, as such it always requires a completely unique uuid token that only the correct client has in order to change data.</p><p>Game related data is stored inside a hashmap on Redis and always kept under a time limit in order to ensure that no unused data clogs the DB up. In order to ensure that game and user sessions are still valid and active, the server requires periodic heartbeats from each client which boil down to a simple &ldquo;Is the player really who they claim they are?&rdquo; on the server. Once again, Rocket makes handling this really easy:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#ff79c6>use</span> redis::Commands;
<span style=color:#ff79c6>use</span> rocket::http::Status;
<span style=color:#ff79c6>use</span> serde::Deserialize;

<span style=color:#ff79c6>use</span> rocket_contrib::json::Json;
<span style=color:#ff79c6>use</span> <span style=color:#ff79c6>crate</span>::db;

<span style=color:#ff79c6>#[derive(Deserialize)]</span><span style=color:#6272a4>// Through this macro, rocket knows what data to expect and how to apply it to the following struct
</span><span style=color:#6272a4></span><span style=color:#ff79c6>pub</span> <span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>Heartbeat</span> { <span style=color:#6272a4>// These are the information the server needs from the user in order to ensure the user is who they are
</span><span style=color:#6272a4></span>    uuid_game: <span style=color:#8be9fd;font-style:italic>String</span>,
    user_id: <span style=color:#8be9fd;font-style:italic>String</span>,
    username: <span style=color:#8be9fd;font-style:italic>String</span>
}

<span style=color:#ff79c6>#[post(</span><span style=color:#f1fa8c>&#34;/heartbeat&#34;</span><span style=color:#ff79c6>, format = </span><span style=color:#f1fa8c>&#34;json&#34;</span><span style=color:#ff79c6>, data = </span><span style=color:#f1fa8c>&#34;&lt;data&gt;&#34;</span><span style=color:#ff79c6>)]</span> 
<span style=color:#6272a4>// This macro simply tells Rocket that we want to listen to post requests for 
</span><span style=color:#6272a4>// this function at &lt;mount_point&gt;/heartbeat and that the data we receive should
</span><span style=color:#6272a4>//  be a JSON and that the JSON should be parsed into the the data parameter of the function
</span><span style=color:#6272a4></span><span style=color:#ff79c6>pub</span> <span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>heartbeat</span>(data: <span style=color:#50fa7b>Json</span><span style=color:#ff79c6>&lt;</span>Heartbeat<span style=color:#ff79c6>&gt;</span>) -&gt; <span style=color:#50fa7b>Status</span> {
    <span style=color:#8be9fd;font-style:italic>let</span> <span style=color:#ff79c6>mut</span> con <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>match</span> db::init_con() { <span style=color:#6272a4>// Connect to the Redis DB
</span><span style=color:#6272a4></span>        <span style=color:#8be9fd;font-style:italic>Ok</span>(con) <span style=color:#ff79c6>=&gt;</span> con,
        <span style=color:#8be9fd;font-style:italic>Err</span>(_err) <span style=color:#ff79c6>=&gt;</span> <span style=color:#ff79c6>return</span> Status::InternalServerError
    };

    <span style=color:#8be9fd;font-style:italic>let</span> uuid_user: <span style=color:#8be9fd;font-style:italic>String</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>match</span> con.hget(format<span style=color:#ff79c6>!</span>(<span style=color:#f1fa8c>&#34;{}:players&#34;</span>, <span style=color:#ff79c6>&amp;</span>data.uuid_game), <span style=color:#ff79c6>&amp;</span>data.username) {
        <span style=color:#8be9fd;font-style:italic>Ok</span>(u) <span style=color:#ff79c6>=&gt;</span> u,
        <span style=color:#8be9fd;font-style:italic>Err</span>(_err) <span style=color:#ff79c6>=&gt;</span> <span style=color:#ff79c6>return</span> Status::InternalServerError
    };

    <span style=color:#ff79c6>if</span> uuid_user <span style=color:#ff79c6>!=</span> data.user_id { <span style=color:#6272a4>// If the user isn&#39;t who they proclaim they are, we return without renewing the data
</span><span style=color:#6272a4></span>        <span style=color:#ff79c6>return</span> Status::Forbidden
    };

    <span style=color:#8be9fd;font-style:italic>let</span> _: () <span style=color:#ff79c6>=</span> con.expire(format<span style=color:#ff79c6>!</span>(<span style=color:#f1fa8c>&#34;{}:players:{}&#34;</span>, <span style=color:#ff79c6>&amp;</span>data.uuid_game, <span style=color:#ff79c6>&amp;</span>data.username), <span style=color:#bd93f9>3</span> <span style=color:#ff79c6>*</span> <span style=color:#bd93f9>60</span>).unwrap(); <span style=color:#6272a4>// Renew session for another 3 minutes
</span><span style=color:#6272a4></span>
    Status::<span style=color:#8be9fd;font-style:italic>Ok</span> <span style=color:#6272a4>// If everything worked, we let the user know through the 200 &#34;OK&#34; status code
</span><span style=color:#6272a4></span>}
</code></pre></div><p>Now we only need to mount the function in our main.rs which is literally just a single line of code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() {
    rocket::ignite()
        .mount(
            <span style=color:#f1fa8c>&#34;/games/lobby/&#34;</span>,
            routes<span style=color:#ff79c6>!</span>[
                <span style=color:#6272a4>// Other functions [...] 
</span><span style=color:#6272a4></span>                games::lobby::heartbeat::heartbeat
            ],
        )
        .launch();
}
</code></pre></div><h3 id=using-godot-as-the-frontend>Using Godot as the frontend</h3><p>Godot uses a scene system in which everything you see and interact with in either code or the UI is its own object and has to be loaded into the current scene tree. At first this is honestly a really confusing concept but the more you use Godot, the easier it gets to use, and it comes with many great upsides.</p><p>Let us look at our scene tree for the main menu:</p><figure class=text-center><img src=godot_ui.png alt="Scene Tree" width=100% height=100%></figure><p>Each UI element (The stuff with green icons) connects to some function in the code through a signal, such as when it is pressed or text is changed. For example, the JoinGameButton button executes this when pressed:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript data-lang=gdscript><span style=color:#ff79c6>func</span> _on_JoinGameButton_pressed():
	<span style=color:#ff79c6>$</span>JoinGame<span style=color:#ff79c6>.</span>JoinGame()
</code></pre></div><p>$JoinGame refers to the &ldquo;JoinGame&rdquo; object in our scene tree, which is its own scene with 2 objects, a neutral node object (basically a dummy object) and one HTTPRequest object. Yes, even HTTPRequests are completely independent objects that need to be spawned into the scene and connected to some signal.</p><p>In this case, we ask the HTTPRequest object called JoinGameRequest to please make a POST request:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript data-lang=gdscript><span style=color:#ff79c6>$</span>JoinGameRequest<span style=color:#ff79c6>.</span>request(
	 global<span style=color:#ff79c6>.</span>server_url <span style=color:#ff79c6>+</span> <span style=color:#f1fa8c>&#34;games/lobby/join_game&#34;</span>,
	 global<span style=color:#ff79c6>.</span>user_agent <span style=color:#ff79c6>+</span> global<span style=color:#ff79c6>.</span>content_type,
	 global<span style=color:#ff79c6>.</span>use_ssl,
	 HTTPClient<span style=color:#ff79c6>.</span>METHOD_POST,
	 JSON<span style=color:#ff79c6>.</span>print(request) <span style=color:#6272a4># Jsonify the request dictionary (identical to Python dictionaries) and then send it as the body</span>
</code></pre></div><p>After it is done requesting the content, it will then respond to the function connected to it&rsquo;s <code>request_completed</code> signal and which point we parse the server response and emit our own signal to the main menu which tells the main menu that we&rsquo;re done joining the game and it is now able to switch the scene to the lobby screen.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript data-lang=gdscript><span style=color:#ff79c6>func</span> _on_JoinGame_joined_game(worked):
	<span style=color:#ff79c6>if</span> <span style=color:#ff79c6>!</span>worked:
		<span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;Couldn&#39;t join game!&#34;</span>)
		<span style=color:#ff79c6>return</span>
		
	global<span style=color:#ff79c6>.</span>goto_scene(<span style=color:#f1fa8c>&#34;res://Scenes/UI/Lobby.tscn&#34;</span>) <span style=color:#6272a4># A user-created function is called that switches our scene to the lobby screen</span>
</code></pre></div><p>If everything works, it ends up looking like this:</p><figure class=text-center><img src=https://user-images.githubusercontent.com/25822956/113868802-5c174800-97b0-11eb-9d9e-38207530e7d1.gif alt="The frontend in action" width=100% height=100%><figcaption><p>Nearly 1700 words and we only explained 1 backend and frontend implementation out of more than 6 API functions needed to get to this point :)</p></figcaption></figure><h3 id=conclusion>Conclusion</h3><p>Game servers are amazing to work with, it feels really interesting to work on two different code bases that are so tightly dependent on each other and yet again so extremely different. I really enjoyed my journey with this project and it once again taught me a lot about Rust.</p><p>I have never focussed on a single project in a dev-blog kind of style in any of my blog posts so I hope that I still managed to make it enjoyable to read this post.</p><p>If you have any questions (or want to follow me on social media), feel free to visit my <a href=https://www.twitter.com/_tomGER>Twitter</a>.</p><p>Lastly, I want to thank all the new readers. Even though I don&rsquo;t track traffic through Google analytics or similar tracking software, the twitter impressions alone showcased a viewership that I never could have imagined receiving. I humbly thank all of you.</p><code class=text-bold>Tags</code>
<a class="chip text-accent" href=https://tomger.eu/%20tags/rust%20>rust</a>
<a class="chip text-accent" href=https://tomger.eu/%20tags/game%20>game</a>
<a class="chip text-accent" href=https://tomger.eu/%20tags/godot%20>godot</a></section><div class="divider my-gap"></div><footer class="col-12 d-inline-block"><span class=float-left><button class="btn btn-action btn-accent shadow s-circle" aria-label=Return onclick=window.history.back();><i class="fas fa-arrow-left"></i></button></span>
<span class=float-right><div class="text-right float-left mx-2"><span class=text-dark>tomGER</span><br><span class=text-gray>Procrastinator</span></div><figure class="avatar avatar-lg"><img id=profile alt></figure><div class=container><a class=symbol href=mailto:blog@tomger.eu target=_blank><i class="fas fa-envelope"></i></a><a class=symbol href=https://www.github.com/tumger aria-label=https://www.github.com/tumger target=_blank rel=me><i class="fab fa-github"></i></a><a class=symbol href=https://norden.social/@tomGER aria-label=https://norden.social/@tomGER target=_blank rel=me><i class="fab fa-mastodon"></i></a></div></span></footer></article><footer class="container p-centered text-center my-gap"><small class=text-gray>Â© Copyright 2022 tomGER<br>Based on spectre-pixel by st-wong</small></footer></div></section><script src=//ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js async defer></script><script src=https://tomger.eu/js/main.js async defer></script><script src=https://tomger.eu/js/highlight.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>